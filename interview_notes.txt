二叉树，平衡二叉树，红黑树

http协议，七层、五层网络模型
五层： 应传网数物
七层： 应表会传网数物
应用层： 文件传输， 电子邮件， 文件服务， 虚拟终端 等 （FTP， HTTP， SMTP， DNS， RIP， Telnet）
表示层： 数据格式化， 代码转换， 数据加密， （没有协议）
会话层： 解除和建立与别的节点的联系， （没有协议）
传输层： 提供端对端接口， TCP， UDP
网络层： 为数据包选择路由， IP， ICMP， OSPF， BGP， IGMP， ARP， RARP
数据链路层： 传输有地址的帧以及错误检测功能， SLIP， CSLIP， PPP， MTU， ARP， RARP
物理层： 以二进制数据形式在物理媒体上传输数据， ISO2110， IEEE802， IEEE802.2


https:
1. 发送https 请求到服务端，服务端返回，客户端获得公钥
2. 客户端生成随机密钥，以作为将来数据传输的对称加密使用
3. 客户端使用第1步获得的公钥，对第2步生成的随机密钥加密，然后发送给服务端
4. 服务端用私钥可以解密客户端发来的信息



mysql 锁机制和事务隔离级别
隔离级别				| 脏读 	| 不可重复读 | 幻读 |
Read Uncommitted	| 	Y	|	Y	   |  Y	 |
Read Committed		|	N	|	Y	   |  Y	 |
Repeatable Read		|	N	|	N	   |  Y	 |
Serializable		| 	N	|	N	   |  N	 |

Read Uncommitted(读取未提交内容)
(1)所有事务都可以看到其他未提交事务的执行结果
(2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少
(3)该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据

Read Committed(读取提交内容)
(1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）
(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变
(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。
     |——>导致这种情况的原因可能有：(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit

Repeatable Read(可重读)
(1)这是MySQL的默认事务隔离级别
(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行
(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行
(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了不可重复读的问题，但是存在幻读的问题。

Serializable(可串行化)
(1)这是最高的隔离级别
(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。
(3)在这个级别，可能导致大量的超时现象和锁竞争

Java并发编程，AQS： AbstractQueueSynchronizer， 抽象队列同步器。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都按照这个模型实现，如常用的ReentrantLock/Semaphore/CountDownLatch.
http://www.cnblogs.com/waterystone/p/4920797.html
AQS 维护一个变量valitile in state (共享资源), 和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。
valitile: 
http://www.importnew.com/18126.html
volatile: 易变的，挥发的。
虚拟机操作数据时，不是直接操作主内存（物理内存），而是分3步：
1. 先复制副本到CPU高速缓存去，
2. 进行运算操作
3. 然后刷新回到主内存
原子性：Java中只有赋值语句是原子性的，比如：int i = 10; 因为这个操作是直接操作主内存的。不过区分： int y = i; 这种不是原子性操作。
可见性：volatile 修饰的变量，保证了可见性，因为对volatile变量的更新会立即刷入主内存。
有序性：指的是代码行在虚拟机中的实际运行顺序。Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。
虽然虚拟机可以对多个代码行进行重排序，但建立在，或者说保证不影响程序结果和行为的基础上。
对volatile的变量操作指令，虚拟机在做重排执行顺序的时候，对volatile的变量操作指令不会改变其相对位置。
volatile关键字禁止指令重排序有两层意思：
1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
比如：
//x、y为非volatile变量
//flag为volatile变量
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5

语句3，肯定能保证还在第三个语句执行，而前面的语句1， 2，和后面的4，5不能保证


在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。


ReentrantLock: 可重入锁，更贴切的说，应该叫可重入排他锁。
state初始化为0（volatile in state = 0;），表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败(排他)，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

JVM, jstack
通过日志分析线程死锁的原因。执行: jstack -l 线程号 >线程号.log
JConsole也可以看。