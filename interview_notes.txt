# Notes
## 二叉树，平衡二叉树，红黑树
1. 二叉查找树/二叉排序树（BST）
* 左子树上所有节点的值都 <= 根节点的值
* 右子树上所有节点的值都 >= 根节点的值
* 左右子树也都是BST（有递归性）
* BST查找的时间复杂度就是二分查找的复杂度，O(logN)
* 二叉树的遍历有3种：先序遍历，中序遍历，后续遍历
* 二叉树删除节点操作：略，回想看看
	* 删除的节点是叶子：
	* 删除的节点没有左子树：
	* 删除的节点没有右子树：
	* 删除的节点左右子树都有：
* 二叉树的插入节点操作：从根结点开始，比较大小，递归的从左右子树插入

BST的缺点主要提现在其插入操作上，如果依次插入的数据本身已经有序，那么插入完成后，BST的结构会呈现一边倒的状态，查询效率大打折扣，几乎成为线性。

2. 平衡二叉树（AVL）
* 因为BST的缺陷，引入节点平衡因子的概念：节点的左右子树高度差，每个节点的平衡因子 <=1，就是AVL。
节点的平衡因子(bf)指：节点的左右子树高度差。
* AVL增加节点时通过旋转操作保持平衡：左旋转，右旋转

因此，AVL在插入性能上较BST略有损耗，因为多了可能的再平衡操作；但在平均的查询性能上得到了提升。


3. 红黑树（RBT）
* 每个节点都是红色或者黑色
* 根结点是黑色的
* 每个叶子节点都是黑色的空节点（NIL）
* 每个红色节点的两个子节点都是黑色（从叶子节点到根结点的路径上不存在两个连续的红色节点）
* 从任意节点到其每个叶子节点路径经过的黑色节点个数相同
* RBT增加节点时以上规则可能会被打破，通过调整保持以上特性，调整有：变色，左旋转，右旋转



## http协议，七层、五层网络模型
* 五层： 应传网数物
* 七层（OSI参考模型）： 应表会传网数物

1. 应用层：文件传输，电子邮件，文件服务，虚拟终端等 （FTP，HTTP，SMTP， 
DNS， RIP， Telnet）
2. 表示层：数据格式化，代码转换，数据加密， （没有协议）
3. 会话层：解除和建立与别的节点的联系， （没有协议）
4. 传输层：提供端对端接口，TCP，UDP
5. 网络层：为数据包选择路由， IP， ICMP，OSPF，BGP，IGMP，ARP，RARP
6. 数据链路层： 传输有地址的帧以及错误检测功能，SLIP，CSLIP，PPP，MTU，ARP， RARP
7. 物理层：以二进制数据形式在物理媒体上传输数据， ISO2110， IEEE802， IEEE802.2


## https:
1. 客户端发送https 请求到服务端，包含密钥算法套件，简称Cipher
2. 服务端收到客户端的请求，检查cipher是否支持，若不支持则断开连接，支持则选择加密算法和hash算法以证书即公钥的形式返回给客户端。
3. 客户端获得公钥。客户端需要对公钥进行是否可信的验证：
	* 根证书的颁发源是否可信，一般的客户端已经预先导入了信任的根证书颁发源，这一步用户可以选择信任证书
	* 证书是否过期
	* 证书中包含的网站地址是否与正在访问的地址一致等
	
	然后客户端生成随机串去加密“握手消息+握手消息的hash（签名）”，然后连同随机密码串，再用公钥加密后发送给服务端。
4. 服务端用用私钥可以解密客户端发来的信息，从而得到客户端随机密钥，用随机密钥再解开得到握手消息和hash值，计算验证hash值是否匹配（确保没有被篡改过）。然后用随机密钥加密握手消息及其hash值返回给客户端（没有随机密钥，因为客户端自己有）。
5. 客户端收到回复的内容密文，可以用自己原有的随机密钥解密，然后对照hash值是否匹配

* 非对称加密算法：RSA，DSA/DSS，在客户端与服务端相互验证的过程中用的是对称加密 
* 对称加密算法：AES，RC4，3DES， 客户端与服务端相互验证通过后，以随机数作为密钥时，就是对称加密
* HASH算法：MD5，SHA1，SHA256  在确认握手消息没有被篡改时 


## mysql 锁机制和事务隔离级别
|隔离级别    		| 脏读 	| 不可重复读 | 幻读 |
|Read Uncommitted	| 	Y	|	Y	   |  Y	 |
|Read Committed		|	N	|	Y	   |  Y	 |
|Repeatable Read	|	N	|	N	   |  Y	 |
|Serializable		| 	N	|	N	   |  N	 |

0. Read Uncommitted(读取未提交内容)
	* 所有事务都可以看到其他未提交事务的执行结果
	* 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少
	* 该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据

1. Read Committed(读取提交内容)
	* 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）
	* 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变
	* 这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中两次执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有：
		* 有一个交叉的事务有新的commit，导致了数据的改变；
		* 一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的commit；

2. Repeatable Read(可重读)
	* 这是MySQL的默认事务隔离级别
	* 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行
	* 此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
	* InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了不可重复读的问题，但是存在幻读的问题。

3. Serializable(可串行化)
	* 这是最高的隔离级别
	* 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。
	* 在这个级别，可能导致大量的超时现象和锁竞争

## Java并发编程，AQS： AbstractQueueSynchronizer， 抽象队列同步器。
AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都按照这个模型实现，如常用的ReentrantLock/Semaphore/CountDownLatch.

[AQS详解](http://www.cnblogs.com/waterystone/p/4920797.html)

AQS 维护一个变量valitile in state (共享资源), 和一个FIFO线程等待队列，多线程争用资源被阻塞时会进入此队列，类似于现实生活中区号排队的场景。


 * ReentrantLock: 可重入锁，更贴切的说，应该叫可重入排他锁。
state初始化为0（volatile in state = 0;），表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败等待(排他)，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。可重入锁最大的作用是避免死锁。

这里需要搞清楚这个锁的原理，为什么能避免死锁？

* 锁消除：虚拟机JIT运行时，虽然代码中存在同步代码块，通过逃逸分析，判断不可能出现多线程共享资源的情况，因此无需加锁，JIT会忽略同步锁。
* 锁粗化：一般情况下，为了使需要同步范围小，让等待的线程尽快拿到锁。但是如果这样粒度小的锁代码块在频繁调用的时候，会导致锁频繁的获取和释放，导致性能损耗。虚拟机检查到这样的情况存在时，会将锁的范围扩大到第一次调用同步代码块开始到最后一次代码块结束。即锁粗化。

[关于 valitile](http://www.importnew.com/18126.html)


## volatile: 易变的，挥发的。
内存操作模型：虚拟机更新内存数据时，不是直接操作主内存（物理内存），而是分3步：
1. 先复制副本到CPU高速缓存去，
2. 进行运算操作
3. 然后刷新回到主内存

因此，这个过程不是原子性的。

* 原子性：Java中只有赋值语句是原子性的，比如：int i = 10;因为这个操作是直接操作主内存的。不过区分： int y = i; 这种不是原子性操作。
* 可见性：volatile 修饰的变量，保证了可见性，因为对volatile变量的更新会立即刷入主内存。
* 有序性：指的是代码行在虚拟机中的实际运行顺序。Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。
虽然虚拟机可以对多个代码行进行重排序，但建立在，或者说保证不影响程序结果和行为的基础上。
对volatile的变量操作指令，虚拟机在做重排执行顺序的时候，对volatile的变量操作指令不会改变其相对位置。
volatile关键字禁止指令重排序有两层意思：
	* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
	* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
比如：
```java
//x、y为非volatile变量
//flag为volatile变量
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```
语句3，肯定能保证还在第三个语句执行，而前面的语句1，2，和后面的4，5不能保证先后，但是1，2肯定在3前执行，而4，5肯定在3后执行。


#### 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），而CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。



## JVM, jstack
通过JVM日志分析排查Java线程死锁
两种办法：使用jstack 命令和jconsole工具
1. jstack
* 首先通过 jps 命令查看需要查看的Java进程的vmid图，得到想查看的进程的id
* 执行: jstack -l <id>：得到一些log，可以看到获取，释放，等待锁等log情况

2. 使用jconsole: 命令行直接jconsole打开jconsole，这是个可视化的工具，可以查看：概览，内存，线程等。其中的线程就可以检测死锁。

